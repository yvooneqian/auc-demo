<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUC 概念详解</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #e0f7fa 0%, #bbdefb 100%);
            color: #2c3e50;
        }
        .container {
            max-width: 1000px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        h1 {
            color: #1a237e;
            text-align: center;
            font-size: 2.8em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #283593;
            border-bottom: 3px solid #5c6bc0;
            padding-bottom: 10px;
            margin-top: 40px;
            font-size: 1.8em;
        }
        .section {
            margin: 30px 0;
            padding: 25px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(200, 200, 200, 0.2);
        }
        .definition {
            background: rgba(179, 229, 252, 0.4);
            border-left: 5px solid #29b6f6;
            padding: 20px;
            margin: 25px 0;
            border-radius: 8px;
            font-size: 1.1em;
            line-height: 1.7;
        }
        .interactive-demo {
            background: rgba(179, 229, 252, 0.3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border: 1px solid rgba(41, 182, 246, 0.3);
        }
        .roc-canvas {
            border: 2px solid #5c6bc0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            margin: 20px auto;
            display: block;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        .controls {
            text-align: center;
            margin: 25px 0;
        }
        .controls button {
            background: linear-gradient(to right, #29b6f6, #0288d1);
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 8px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(41, 182, 246, 0.3);
            transition: all 0.3s ease;
        }
        .controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(41, 182, 246, 0.4);
        }
        .controls button:active {
            transform: translateY(1px);
        }
        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 25px 0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 20px;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        .legend-color {
            width: 22px;
            height: 22px;
            margin-right: 10px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .perfect-model { background: #00c853; }
        .random_model { background: #ff9100; }
        .poor_model { background: #ff1744; }
        .formula {
            background: rgba(255, 245, 157, 0.4);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.3em;
            margin: 25px 0;
            border: 2px dashed #ffd600;
            font-weight: bold;
            color: #1a237e;
        }
        .example-box {
            background: rgba(200, 230, 201, 0.4);
            border: 2px solid #66bb6a;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            font-size: 1.05em;
        }
        .interpretation {
            background: rgba(255, 204, 188, 0.4);
            border: 2px solid #ff8a65;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            font-size: 1.05em;
        }
        ul {
            padding-left: 25px;
        }
        li {
            margin-bottom: 12px;
            line-height: 1.7;
        }
        .highlight {
            background: linear-gradient(120deg, #80deea 0%, #4dd0e1 100%);
            padding: 3px 8px;
            border-radius: 5px;
            font-weight: bold;
            color: #01579b;
        }
        .note {
            background: rgba(255, 255, 255, 0.7);
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            border-left: 5px solid #7e57c2;
            font-size: 1.05em;
        }
        .note strong {
            color: #4527a0;
        }
        .note ul {
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎯 AUC 概念详解</h1>
        
        <div class="section">
            <div class="definition">
                <strong>AUC (Area Under the Curve)</strong> 是 ROC 曲线下方的面积，用于衡量二分类模型性能的重要指标。AUC 值越大，模型的分类能力越强。
            </div>
        </div>

        <div class="section">
            <h2>📊 什么是 ROC 曲线？</h2>
            <p>ROC 曲线（Receiver Operating Characteristic Curve）是以假正率（FPR）为横轴，真正率（TPR）为纵轴绘制的曲线。</p>
            <div class="formula">
                TPR = TP / (TP + FN) &nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp; FPR = FP / (FP + TN)
            </div>
            <p>其中：</p>
            <ul>
                <li><strong>TP (True Positive)</strong>：真正例，预测为正且实际为正</li>
                <li><strong>FN (False Negative)</strong>：假负例，预测为负但实际为正</li>
                <li><strong>FP (False Positive)</strong>：假正例，预测为正但实际为负</li>
                <li><strong>TN (True Negative)</strong>：真负例，预测为负且实际为负</li>
            </ul>
        </div>

        <div class="section">
            <h2>🎮 交互式演示</h2>
            <div class="interactive-demo">
                <canvas id="rocCanvas" class="roc-canvas" width="600" height="400"></canvas>
                <div class="controls">
                    <button onclick="drawPerfectModel()">完美模型 (AUC = 1.0)</button>
                    <button onclick="drawGoodModel()">好模型 (AUC = 0.85)</button>
                    <button onclick="drawRandomModel()">随机模型 (AUC = 0.5)</button>
                    <button onclick="drawPoorModel()">差模型 (AUC = 0.3)</button>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color perfect_model"></div>
                        <span>完美模型 (AUC = 1.0)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50;"></div>
                        <span>好模型 (AUC = 0.85)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color random_model"></div>
                        <span>随机模型 (AUC = 0.5)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color poor_model"></div>
                        <span>差模型 (AUC = 0.3)</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>📈 AUC 值的解释</h2>
            <div class="interpretation">
                <p><strong>AUC 值的范围：0.5 ~ 1.0</strong></p>
                <ul>
                    <li><span class="highlight">AUC = 1.0</span>：完美分类器，能够完全区分正负样本</li>
                    <li><span class="highlight">0.9 ≤ AUC < 1.0</span>：优秀分类器，分类效果很好</li>
                    <li><span class="highlight">0.8 ≤ AUC < 0.9</span>：良好分类器，分类效果较好</li>
                    <li><span class="highlight">0.7 ≤ AUC < 0.8</span>：一般分类器，分类效果一般</li>
                    <li><span class="highlight">0.6 ≤ AUC < 0.7</span>：较差分类器，分类效果较差</li>
                    <li><span class="highlight">0.5 ≤ AUC < 0.6</span>：很差分类器，几乎等同于随机猜测</li>
                    <li><span class="highlight">AUC = 0.5</span>：随机分类器，与随机猜测相同</li>
                    <li><span class="highlight">AUC < 0.5</span>：比随机猜测还差，可以通过反转预测结果得到 AUC > 0.5</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>💡 AUC 的优点</h2>
            <div class="example-box">
                <ul>
                    <li><strong>不受类别不平衡影响</strong>：AUC 对正负样本比例不敏感，适用于不平衡数据集</li>
                    <li><strong>综合性能评估</strong>：AUC 综合考虑了模型在不同阈值下的性能，比单一阈值指标更全面</li>
                    <li><strong>无需设定阈值</strong>：AUC 不依赖于特定的分类阈值，可以评估模型的整体排序能力</li>
                    <li><strong>直观易懂</strong>：AUC 值范围固定，便于不同模型之间的比较</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>📝 计算示例</h2>
            <div class="example-box">
                <p>假设有一个二分类问题，我们有以下预测结果和真实标签：</p>
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                    <tr style="background: #f0f0f0;">
                        <th style="border: 1px solid #ddd; padding: 8px;">样本</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">真实标签</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">预测概率</th>
                    </tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">1</td><td style="border: 1px solid #ddd; padding: 8px;">正</td><td style="border: 1px solid #ddd; padding: 8px;">0.9</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">2</td><td style="border: 1px solid #ddd; padding: 8px;">负</td><td style="border: 1px solid #ddd; padding: 8px;">0.8</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">3</td><td style="border: 1px solid #ddd; padding: 8px;">正</td><td style="border: 1px solid #ddd; padding: 8px;">0.7</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">4</td><td style="border: 1px solid #ddd; padding: 8px;">负</td><td style="border: 1px solid #ddd; padding: 8px;">0.6</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">5</td><td style="border: 1px solid #ddd; padding: 8px;">正</td><td style="border: 1px solid #ddd; padding: 8px;">0.5</td></tr>
                </table>
                <p>通过计算不同阈值下的 TPR 和 FPR，可以绘制 ROC 曲线并计算 AUC 值。</p>
            </div>
        </div>

        <div class="section">
            <h2>⚠️ 注意事项</h2>
            <div class="note">
                <p><strong>使用 AUC 时需要注意：</strong></p>
                <ul>
                    <li>AUC 只关注模型的排序能力，不关注预测概率的准确性</li>
                    <li>在某些特定场景下，AUC 可能不是最佳评估指标</li>
                    <li>对于多分类问题，需要使用其他评估指标或计算多个 AUC</li>
                    <li>AUC 高不一定代表模型在实际应用中表现好，还需要结合业务需求</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('rocCanvas');
        const ctx = canvas.getContext('2d');

        function drawAxes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#1a237e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 350);
            ctx.lineTo(550, 350);
            ctx.moveTo(50, 350);
            ctx.lineTo(50, 50);
            ctx.stroke();
            
            // 绘制刻度
            ctx.font = '14px Arial';
            ctx.fillStyle = '#1a237e';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 10; i++) {
                const x = 50 + i * 50;
                const y = 350 - i * 30;
                
                // X轴刻度
                ctx.fillText((i / 10).toFixed(1), x, 375);
                ctx.beginPath();
                ctx.moveTo(x, 345);
                ctx.lineTo(x, 355);
                ctx.stroke();
                
                // Y轴刻度
                if (i > 0) {
                    ctx.textAlign = 'right';
                    ctx.fillText((i / 10).toFixed(1), 45, y + 5);
                    ctx.beginPath();
                    ctx.moveTo(45, y);
                    ctx.lineTo(55, y);
                    ctx.stroke();
                }
            }
            
            // 轴标签
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#1a237e';
            ctx.textAlign = 'center';
            ctx.fillText('假正率 (FPR)', 300, 400);
            ctx.save();
            ctx.translate(20, 200);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('真正率 (TPR)', 0, 0);
            ctx.restore();
            
            // 绘制对角线（随机模型）
            ctx.strokeStyle = '#90a4ae';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(50, 350);
            ctx.lineTo(550, 50);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 添加网格线
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 1; i < 10; i++) {
                const pos = 50 + i * 50;
                ctx.beginPath();
                ctx.moveTo(pos, 50);
                ctx.lineTo(pos, 350);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(50, 50 + i * 30);
                ctx.lineTo(550, 50 + i * 30);
                ctx.stroke();
            }
        }

        function drawROC(curveData, color, label, lineWidth = 4) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            for (let i = 0; i < curveData.length; i++) {
                const x = 50 + curveData[i].fpr * 500;
                const y = 350 - curveData[i].tpr * 300;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // 添加数据点
            ctx.fillStyle = color;
            for (let i = 0; i < curveData.length; i += 3) {
                const x = 50 + curveData[i].fpr * 500;
                const y = 350 - curveData[i].tpr * 300;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 添加标签
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#1a237e';
            if (curveData.length > 10) {
                const midIndex = Math.floor(curveData.length / 2);
                const labelX = 50 + curveData[midIndex].fpr * 500 + 15;
                const labelY = 350 - curveData[midIndex].tpr * 300;
                ctx.fillText(`AUC = ${curveData[0].auc}`, labelX, labelY);
            }
        }

        function generatePerfectModel() {
            const curve = [];
            for (let i = 0; i <= 100; i++) {
                curve.push({
                    fpr: i / 100,
                    tpr: i === 0 ? 0 : 1,
                    auc: 1.0
                });
            }
            return curve;
        }

        function generateGoodModel() {
            const curve = [];
            for (let i = 0; i <= 100; i++) {
                const fpr = i / 100;
                const tpr = Math.pow(fpr, 0.3) * 0.95;
                curve.push({ fpr, tpr, auc: 0.85 });
            }
            return curve;
        }

        function generateRandomModel() {
            const curve = [];
            for (let i = 0; i <= 100; i++) {
                curve.push({
                    fpr: i / 100,
                    tpr: i / 100,
                    auc: 0.5
                });
            }
            return curve;
        }

        function generatePoorModel() {
            const curve = [];
            for (let i = 0; i <= 100; i++) {
                const fpr = i / 100;
                const tpr = fpr * 0.3;
                curve.push({ fpr, tpr, auc: 0.3 });
            }
            return curve;
        }

        function drawPerfectModel() {
            drawAxes();
            drawROC(generatePerfectModel(), '#00c853', '完美模型');
        }

        function drawGoodModel() {
            drawAxes();
            drawROC(generateGoodModel(), '#29b6f6', '好模型');
        }

        function drawRandomModel() {
            drawAxes();
            drawROC(generateRandomModel(), '#ff9100', '随机模型');
        }

        function drawPoorModel() {
            drawAxes();
            drawROC(generatePoorModel(), '#ff5252', '差模型');
        }

        // 初始绘制
        drawAxes();
        drawROC(generateGoodModel(), '#29b6f6', '好模型');
    </script>
</body>
</html>